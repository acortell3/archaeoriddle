pos <- c(rep(0,st),new)
pos <- pos[1:matdim]
mat[,i] <- pos
}
mat[is.na(mat)] <- 0
## Names for columns (each year)
years <- seq(InitBP, InitBP-ts)
nyears <- c()
for (i in 1:matdim){
nyears[i] <- paste0(years[i], " BP")
}
colnames(mat) <- nyears
## Names for rows (each depth)
## Extract arguments as a list
Extract_param <- function(x, ...){
extras <- list(...)
return(list(extras=extras))
}
dr <- Extract_param(D_along, ...)
dr <- dr$extras$r
d <- rev(cumsum(rep(dr,nrow(mat)))) ## computes depths
rownames(mat) <- paste0("d = ", d, " cm")
return(mat)
}
set.seed(1234)
Ps <- Pop_stoch(Pop=100, ts= 100, K = 150)
samp <- unlist(lapply(Ps, A_rates)) ## Extract sample per time steps
Rec <- Rec_c(samp, InitBP = 7500, ts = 100, r = 0.2, Max_bone_thickness = "m")
set.seed(1234)
Ps <- Pop_stoch(Pop=100, ts= 100, K = 150)
samp <- unlist(lapply(Ps, A_rates)) ## Extract sample per time steps
Rec <- Rec_c(samp, InitBP = 7500, ts = 100, r = 0.2, max_bone_thickness = "m")
Ps
samp
Rec
Ps
Rec
Rec
data.frame(Rec)
Rec
## Some nice plots
library(viridis)
## Plot dates
#sdate <- 1
#edate <- 5
#sdepth <- 1
#edepth <- 5
#barplot(Rec[sdepth:edepth,sdate:edate], col = viridis(10), legend = rownames(Rec)[sdate:edate],
#        xlab = "Years BP", ylab = "nsamples", main = "Distribution of samples for each year at different depths")
tRec <- t(Rec)
barplot(tRec[c(1:4,77:79),], col = viridis(10), legend = colnames(Rec)[c(1:4,77:79)],
xlab = "Depth", ylab = "nsamples", main = "Distribution of specific years along depth with population")
lines(Ps*300, col = "darkred", lwd = 1.5)
## Some nice plots
library(viridis)
## Plot dates
sdate <- 1
edate <- 5
sdepth <- 1
edepth <- 5
barplot(Rec[sdepth:edepth,sdate:edate], col = viridis(10), legend = rownames(Rec)[sdate:edate],
xlab = "Years BP", ylab = "nsamples", main = "Distribution of samples for each year at different depths")
tRec <- t(Rec)
barplot(tRec[c(1:4,77:79),], col = viridis(10), legend = colnames(Rec)[c(1:4,77:79)],
xlab = "Depth", ylab = "nsamples", main = "Distribution of specific years along depth with population")
lines(Ps*300, col = "darkred", lwd = 1.5)
Rec
barplot(tRec[c(1:4,77:79),], col = viridis(10), legend = colnames(Rec)[c(1:4,77:79)],
xlab = "Depth", ylab = "# samples", main = "Distribution of specific years along depth with population")
library(DiagrammeR)
grViz("
digraph record_formation {
graph [layout = dot, ## Set title and layout
label = 'Record loss process',
labelloc = 't'
fontname = Helvetica,
fontsize = 30]
# node definitions with substituted label text
node [fontname = Helvetica, ## General node definition
style = filled,
color = MistyRose]
## Per node definition
a [label = '@@1',
fillcolor = orange]
b [label = '@@2',
fillcolor = orange]
c [label = '@@3',
fillcolor = cadetblue,
fixedsize = shape,
width = 8.5,
height = 1.5,
fontsize = 30]
## General edge definition
edge [color = grey,
arrowhead = vee,
arrowtail = vee]
## Specific edges
a -> {c}
b -> {c}
}
## Label definition
[1]: 'Low impact - long term action'
[2]: 'High impact - short term action'
[3]: 'Remaining archaeological waste'
")
install.packages('printr')
library(prinr)
library(printr)
source('tools.R')
printr(Gdp)
?printr
source('tools.R')
help(Gdp)
source('tools.R')
??Gdp
source('tools.R')
help(Gdp)
library(devtools)
load_all()
source('tools.R')
Gdp
source('tools.R')
help(Gpd)
??Gpd
str(Gpd)
source('tools.R')
help('Gpd')
### Population protocol
## Function 1.
#' @title Generation of population dynamics
#' Protocol to generate a stochastic demographic process
#' @param x Input data with initial population matrix. A data frame or matrix
#' with two columns and nrow = Initial population. One row per individual.
#' The first column is the age of the individual.
#' The second column is the sex of the individual, and must be c("F","M").
#' The columns must be named Age and Sex respectively.
#' @param K Carrying capacity.
#' @param W_fert_age Vector with two values. The first value is the youngest age
#' at which is considered that women can have children for prehistoric societies.
#'  The second value is the oldest age at which is considered that women can
#'  have children. Default is c(10,30).
#' @param M_fert_age Vector with two values. The first value is the youngest age
#' at which is considered that men can have children for prehistoric societies.
#' The second value is the oldest age at which is considered that men can have
#' children. Default is c(15,40)
#' @param p_offspring: Probability of a woman having a son per year. Default is 0.3.
#' @param prob Probability that an individual will die per year if total population
#' exceeds K. Default is 0.8
#' @param ... Arguments passed to [death()]. The mortality probability by age matrix.
#' Their arguments can be added.
#' @return data.frame with two columns, where the number of rows is the number of
#' people. The first column contains the ages and the second column contains the sex.
#' @export
Gpd <- function(x, K, W_fert_age = c(10, 45), M_fert_age = c(15, 55),
p_offspring = 0.3, prob = 0.8, ...){
### Process of having offspring
# Female fertile population
W <- x[x[,2]=="F", ]
W_fert <- W[W$Age > W_fert_age[1] & W$Age < W_fert_age[2], ]
# Male fertile population
M <- x[x[,2]=="M", ]
M_fert <- M[M$Age > M_fert_age[1] & M$Age < M_fert_age[2], ]
## Probability of having descendance per woman
# Penalisation in case there are too few men
pen <- round(nrow(M_fert)*2 / nrow(W_fert), 2) ## Assumes one man can have two women
pen[pen>1] <- 1 ## The men penalisation can never multiply the birth rate per woman
## Probability of a woman having a son per year
p_offspring <- p_offspring*pen
# Aging process. They get one year older
x$Age <- x$Age+1
### Births are new population that's added
n_offspring <- sum(rbinom(nrow(W_fert), 1, p_offspring))
new_pop <- data.frame(
"Age" = rep(0, n_offspring),
"Sex" = sample(c("M","F"), n_offspring, prob=c(0.5, 0.5), replace=TRUE))
x <- rbind(x, new_pop)
### Process of dying
vec_d <- apply(x, 1, death, ...)
x <- x[vec_d==0, ]
## Apply carrying capacty restrictions
x <- K_lim(x, K = K, prob = prob)
return(x)
}
## Function 2. Simulation of death process
#' @title Simulation of death process
#' For a single individual, returns whether it lives (0) or dies (1)
#' Meant to be used with apply on the population data.frame x
#' @param x A vector or data.frame with a single row from the population matrix.
#' It must contain two values or columns, Age and Sex
#' @param pd The probability matrix for mortality by age
#' The age-structured data frame is based on Gurven, Kaplan and Supa, 2007.
#' It is extracted adapted after computation from their text (not graphs or tables)
#' @return A value (0,1) where 0 = person lives and 1 = person dies, based
#' on pd (the probability matrix)
#' @export
death <- function(x, pd=data.frame("Age" = c(0:99),
"P_d" = c(rep(0.14,1),
rep(0.16,4),
rep(0.05,5),
rep(0.01,24),
rep(0.03,14),
rep(0.1,10),
rep(0.3,42)))){
age <- as.numeric(x[1])
return(rbinom(1, 1, prob=pd[pd$Age==age, 2]))
}
## Function 3. Simulation of carrying capacity limitation
#' @title Simulation of carrying capacity limitation
#' If the population exceeds the carrying capacity, it eliminates oversize
#' with prob probability per person exceeding.
#' @param x Data frame or matrix. Population (number of people)
#' @param K Integer. Carrying capacity. Provided by the user
#' @param prob It is the probability of dying when surpassing carrying capacity
#' @export
K_lim <- function(x, K, prob=0.8){
p <- nrow(x)
if (p>K){
o <- rbinom(p-K, 1, prob)
o <- sum(o[o==1])
o[o==0] <- 1 ## Avoids problem eliminating all the df if remove == 0
x <- x[-sample(1:nrow(x), o, replace=FALSE), ]
}
return(x)
}
help('Gpd')
help(Gpd)
source('tools.R')
utils:::.getHelpFile(help('Gpd'))
source('tools.R')
utils:::.getHelpFile('Gpd')
source('tools.R')
utils:::getHelpFile('Gpd')
help(mean)
?mean
??mean
library(printr)
Gpd
help(Gpd)
?knitr::stitch
knitr::stitch('tools.R')
pwd()
getwd()
source('tools.R')
knitr::stitch('tools.R')
source('tools.R')
knitr::stitch(stitch('tools.R', system.file("misc", "knitr-template.Rmd", package = "knitr")))
source('tools.R')
knitr::stitch('tools.R', system.file("misc", "knitr-template.Rmd", package = "knitr"))
source('tools.R')
knitr::stitch('tools.R', system.file("misc", "knitr-template.Rmd", package = "knitr"))
source('tools.R')
knitr::spin('tools.R')
source('tools.R')
knitr::spin('tools.R', knit=F, report = F)
source('tools.R')
knitr::spin('tools.R', output='md', knit=F, report = F)
source('tools.R')
knitr::spin('tools.R', output='Rmd', knit=T, report = F)
source('tools.R')
knitr::spin('tools.R', format='Rmd', knit=T, report = F)
source('tools.R')
knitr::spin('tools.R', format='Rmd', knit=T, report = T)
help(mean)
help(mean)
help(mean)
library(readr)
help(mean)
library(readr)
help.search('mean')
library(readr)
help.search('mean')
library(printr)
?mean
library(devtools)
?create_package
create_package('doc/archaeoriddle')
?document
document('doc/bookdown/')
document('doc/bookdown/R')
getwd()
?use_description
use_description()
?use_namespace
use_namespace()
?use_build_ignore
use_build_ignore()
use_build_ignore(c('doc', 'div', '.git', 'tex_files', 'README.md', 'collaborabm.Rproj', '.Rproj.user', 'Explanation_of_ideas_brain_map.md', 'interactive_brain_map.md', 'pop_id.Rmd'))
?use_r
use_r('tools')
load_all()
document()
?Gpd
?Gpd
library(printr)
?Gpd
library(printr)
print(Gpd)
library(printr)
cat(Gpd)
library(printr)
cat(print(Gpd))
library(printr)
print(Gpd)
library(printr)
print(Gpd)
library(printr)
print(paste0('`', Gpd, '`'))
library(printr)
print(paste0('`', str(Gpd), '`'))
library(printr)
print(paste0('`', str(Gpd), '`'))
library(printr)
print(Gpd)
library(printr)
print(Gpd)
library(printr)
print(Gpd)
library(printr)
print(Gpd)
library(printr)
print(Gpd)
library(printr)
print(Gpd)
library(printr)
print(paste0('`a <- 2`'))
print(Gpd)
library(printr)
paste0('`a <- 2`')
print(Gpd)
library(printr)
cat(paste0('`a <- 2`'))
print(Gpd)
library(printr)
cat(paste0('`a <- 2`\n'))
print(Gpd)
library(printr)
?Gpd
print(Gpd)
library(printr)
?Gpd
print(paste0('\n', Gpd))
library(printr)
?Gpd
print('\n')
print(Gpd)
library(printr)
?Gpd
Gpd
load_all()
library(printr)
?Gpd
Gpd
library(devtools)
library(printr)
?Gpd
Gpd
library(printr)
?Gpd
Gpd
load_all()
library(printr)
?Gpd
Gpd
document()
library(printr)
?Gpd
Gpd
document()
?Rec_c
document()
?Rec_c
?Gpd
document()
?Gpd
document()
?D_along
?Pop_stoch
print(Pop_stoch)
?Rec_c
print(Rec_c)
?D_along
print(D_along)
?D_along
print('\n')
print(D_along)
?Pop_stoch
print('\n')
print(Pop_stoch)
?Rec_c
print(Rec_c)
?knitr::knit_code
?knitr::knit_theme
?knitr::spin_child
library(printr)
?Gpd
Gpd
getwd()
library(printr)
?Gpd
knitr::spin_child('R/tools.R')
getwd()
library(printr)
?Gpd
knitr::spin_child('../../R/tools.R')
document()
library(bookdown)
?knitr::spin
load_all()
document()
document()
?knitr::spin_child
knitr::spin('../../R/tools.R', comment=c("#'","#'"))
document()
use_r('population_protocol')
use_r('anthropogenic_deposition')
use_r('natural_deposition')
document()
?knitr::knit_child
knitr::spin('../../R/population.R', comment=c("#'","#'"))
knitr::spin('../../R/population.R', report=TRUE, comment=c("#'","#'"))
knitr::spin('../../R/population.R', format='Rmd', report=TRUE, comment=c("#'","#'"))
knitr::spin('../../R/population.R', format='Rmd', report=FALSE, comment=c("#'","#'"))
library(printr)
?Gpd
knitr::spin('../../R/population.R', format='Rmd', report=FALSE, comment=c("#'","#'"))
knitr::knit_child('population.md')
?knit_child
library(printr)
?Gpd
knitr::spin('../../R/population.R', format='Rmd', report=FALSE, comment=c("#'","#'"))
knitr::knit_child('population.md', output='population.html')
knitr::knit_child('population.md', output='population.html', options=list('output.dir'='.'))
?spin_child
knitr::spin('../../R/population.R', format='Rmd', report=TRUE, comment=c("#'","#'"))
?spin
knitr::spin('../../R/population.R', format='Rmd', comment=c("#'","#'"),
precious=TRUE)
knitr::spin('../../R/population.R', format='Rmd', comment=c("#'","#'"),
precious=TRUE)
knitr::spin('../../R/population.R', format='Rmd', comment=c("#'","#'"),
precious=TRUE)
knitr::spin('../../R/population.R', format='Rmd', comment=c("#'","#'"),
precious=TRUE, knit=FALSE, report=FALSE)
library(printr)
knitr::spin('../../R/population.R', format='Rmd', comment=c("#'","#'"),
precious=TRUE, knit=FALSE, report=FALSE)
# knitr::knit_child('population.Rmd')
library(fs)
?fs::file_move
library(printr)
knitr::spin('../../R/population.R', format='Rmd', comment=c("#'","#'"),
precious=TRUE, knit=FALSE, report=FALSE)
fs::file_move('../../R/population.Rmd', '.')
# knitr::knit_child('population.Rmd')
document()
load_all()
library(devtools)
document()
# Pop_stoch
# Rec_c
# D_along
set.seed(1234)
# 1. Pop-protocol
Ps <- Pop_stoch(pop_size=100, ts=100, K=150)
# 2. A-protocol
samp <- unlist(lapply(Ps, A_rates)) ## Extract sample per time steps
# 3. D-protocol
Rec <- Rec_c(samp, InitBP = 7500, ts = 100, r = 0.2, max_bone_thickness = "m")
## Some nice plots
library(viridis)
## Plot dates
sdate <- 1
edate <- 5
sdepth <- 1
edepth <- 5
barplot(Rec[sdepth:edepth,sdate:edate], col = viridis(10), legend = rownames(Rec)[sdate:edate],
xlab = "Years BP", ylab = "# samples", main = "Distribution of samples for each year at different depths")
tRec <- t(Rec)
barplot(tRec[c(1:4,77:79),], col = viridis(10), legend = colnames(Rec)[c(1:4,77:79)],
xlab = "Depth", ylab = "# samples", main = "Distribution of specific years along depth with population")
lines(Ps*300, col = "darkred", lwd = 1.5)
?lapply
check()
.Last.error
install()
use_build_ignore('doc/')
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::build() %>%
install.packages(repos = NULL, type = "source")
library(magrittr)
devtools::build() %>%
install.packages(repos = NULL, type = "source")
install()
devtools::build() %>%
install.packages(repos = NULL, type = "source")
build()
use_build_ignore('doc')
use_build_ignore('doc')
build()
devtools::build()
?install.packages
library(collaborabm)
?knit
?knit_child
?document
document()
knit_with_parameters("~/cdal/collaborabm/doc/bookdown/01_Record_formation.Rmd")
