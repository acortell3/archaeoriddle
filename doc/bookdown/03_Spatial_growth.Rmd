# Population growth on multiple sites

Population will then grow, for years, and years. This implies multiple things: they need ressources, and we need to define a way for them to grow.

## Environmental resources

We will generate zones of high resources, that will attract settlements and support higher K.
The resources will be located at given hotspots with an area around in which they decay
with a logistic function. We provide a very basic function `logisticdecay` which allow to define multiple source with different decay array around them.

```{r, echo=FALSE}
?logisticdecay
```


```{r, echo=FALSE, message=FALSE}
a = knitr::spin('../../R/logistic_decay.R', format='Rmd', comment=c("#'","#'"),
            precious=TRUE, knit=FALSE, report=FALSE)
fs::file_move('../../R/logistic_decay.Rmd', '.')
```

Here's the code for the generation of resources under logistic decay 
<details><summary>Show code</summary>
**Code**
```{r, echo=FALSE, results='asis'}
res = knitr::knit_child(input='logistic_decay.Rmd', quiet=TRUE)
cat(res, sep = '\n')
fs::file_delete('logistic_decay.Rmd')
```
</details>

<br>

For the _archaeoriddle_, thes hotspots and there radius were manually selected given the topography. These manual setups are given below:

```{r}
##ressource geolocalisation set manually
goodresources <- vect(
  cbind(
    x=c(-0.2300711, -3.1455282, -0.5086485, -1.9639755,
        -0.4077843, 0.019688, -3.116710),
    y=c(3.6423000, -0.2551019, -0.7440748, 1.1303214,
        1.0248567, 0.2194895, 2.0267718)
  )
)
#spread of resources
areas <- 4 * c(100, 2000, 200, 300, 100, 200, 400)
#speed of ressource decay:
ks <- c(0.0002, 0.0001000, 0.0001600, 0.0001800, 0.00040, .0002, 0.0002)/4


crs(goodresources) <- crs(original.ras)
```

The function `logisticdecay` generates individual rasters for all the identified hotspots, which are then merged to create an aggregate raster referred to as 'resources'.

When considering the selection of hotspots, one may choose to retain the one utilized for the _archaeoriddle_, although its center may be positioned in water based on the preceding generation outcome. Choosing them manual remains the best option, one can use `locator()` to find the coordinates of the hotspot by click on the raster.

```{r}

allres <- lapply(
  seq_along(goodresources),
  function(i){
    logisticdecay(goodresources[i], mask(height.ras, viable),
                  x=areas[i], k=ks[i]
    )
  }
)

allna <- sapply(allres, function(i)any(is.na(values(i))))
allres <- allres[!allna]

ress <- allres[[1]]
for(i in 2:length(allres))
    ress <- ress + allres[[i]]
ress <- mask(ress,viable)
plot(ress)
```

This is also something that will be share with participants and thus will be saved in the folder with the DEM and the coastline.

```{r saveResources}
writeRaster(filename=file.path(foldname,"resources.tiff"), ress, overwrite=T) #write the resources as a raster
```



## Initial sites and size:

We now have an environment with ressources that we can use to define the size of each sites.
We will assign a groups, `HG` and `F` for each sites.

We first define all sites has hunter gatherer, except the mosts south west one. Note that this made sence in the archaeoriddle as we had a piece of land south west ; you may want to manually choose the site.

```{r,eval=T}
cultures <- rep("HG",length(sites))
sw <- which.min(sqrt((crds(sites)[,"x"] - min(crds(sites)[,"x"]))^2 + (crds(sites)[,"y"] - min(crds(sites)[,"y"]))^2))
cultures[sw]="F"
sites$culture <- cultures

plotMap(height.ras,height.wat)
points(crds(sites),bg=as.factor(cultures),pch=21,cex=1.3)
```


The each site will then be assigned a carrying capacity (how many people can leave on the site), defined using the ressource raster and the culture. 

```{r computeK}

Kbase <- c("HG"=45,"F"=120) #difference in base-K for the two cultures

# The base Ks  are then modulated given the ressource raster
sites$Ks <- initKs(Kbase, sites, ress, sizeexp="F")
```

Using these carrying capacities, we then set initial number of people, and the population structure for each sites:

```{r computeIN}
# Optionally we can intialize here our list of sites and population structures
# Otherwise, they are initialized within the run_simulation function
# Population size at initialisation, a number close to Ks
INs <- round(runif(length(sites), 0.85, 0.95)*sites$Ks)

# initialise population structure for all sites
Ips <- lapply(INs, initpopstruc)

# Not we put the population structure across the years in a matrix: each row will represent a time step of the simulation ; each column a sites
Nts <- initlistsites(Ips, ts=250)

```

We can look at the population structure of the biggest sites:

```{r agestruc,out.width="40%",fig.show="hold"}
biggest <- which.max(INs)
pop.biggest <- Ips[[biggest]]
poplist=sapply(c(F="F",M="M"),function(s)table(cut(pop.biggest[pop.biggest[,2]==s,1],breaks=seq(0,40,4))))
par(mar=c(1,10,1,1))
barplot(-poplist[,1],beside=T,horiz=T,col=c("blue"),axes=F,las=1)
par(mar=c(1,1,1,10))
barplot(unname(poplist[,1]),beside=T,horiz=T,col=c("red"),axes=F)
```


You can see the code of `initKs`, `initpopstruct` and `initlistsites` functions here:
<details><summary>Show code</summary>
**Code**

```{r, echo=FALSE, results='asis'}
a = knitr::spin('../../R/init_simulation.R', format='Rmd', comment=c("#'","#'"),
            precious=TRUE, knit=FALSE, report=FALSE)
fs::file_move('../../R/init_simulation.Rmd', '.')

res = knitr::knit_child(input='init_simulation.Rmd', quiet=TRUE)
cat(res, sep = '\n')
fs::file_delete('init_simulation.Rmd')
```
</details>


We now have sites with two cultures. The grow of the sites will depend on a lot of paparemeters; which are all a bit different depending on the two cultures. The list of parameters used is deined below: 

```{r}

#(read sites saved before)
# sites=readRDS(file="data_original/sitesinitialposition/",sites)


#initialisation

ts <- 250  # length of populaton

Kbase=c("HG"=45,"F"=120) #difference in K for the two cultures use and defined before ; will be use in simulation to define new site

# spatial penality for cultural extentions, ie for population to move out of initial site : lower, bigger penality
cul_ext <- c("HG"=7, "F"=6)

# penality of occupational area ie how hard it is to come close to your site ; if low, other sites can come close
penal_cul <- c("HG"=4, "F"=5)
# proba to give birth every year
prob_birth <- c("HG"=0.3, "F"=0.5)
# proba to die when pop > K
prob_survive <- c("HG"=0.8, "F"=0.6)
# proba to create new settlement when Ne > K
prob_split <- c("HG"=0.2, "F"=0.6)
# how big the group of migrant should be to create a new city vs
# migrate to a existing one
minimals <- c("HG"=0.14, "F"=0.20)
# prob to migrate to existing settlement when Ne > K
prob_move <- c("HG"=0.2,"F"=0.1)
```

Let's see our raster map again, and put the sites on top, with their ids and showing there initial population size:
```{r}
plotMap(height.ras,height.wat,paste0("year ", 0))
plot(sites, pch=21, add=T, bg=rainbow(2, alpha=0.6)[as.factor(sites$culture)],cex=(1+Nts[1,]/100))
text(sites)
```

The `run_simulation` function will take the raster data and parameters for defined before for the two different cultures and run for the specified number of years `ts` (`r ts`).

<br>

```{r, echo=FALSE}
?run_simulation
```
<br>

It uses a number of other functions to model contacts between sites, the outcomes of fights and migrations

<br>

```{r, echo=FALSE}
?whotouch
```
<br>

<br>

```{r, echo=FALSE}
?fightbetterloss
```
<br>

<br>

```{r, echo=FALSE}
?changePopSize
```
<br>

<br>

```{r, echo=FALSE}
?warpoints
```
<br>


```{r,eval=T}


onesimu <- run_simulation(
  sites=sites, viable=viable, dem=height.ras,
  ressources=ress,
  water=height.wat,
  foldervid="nan",
  visu=T, visumin=T,
  ts=10, #length of simulation in year
  Kbase=c("HG"=35, "F"=110), #difference in K for the two cultures
  cul_ext=c("HG"=7, "F"=6), #spatial penality to extent: lower, bigger penality
  penal_cul=c("HG"=4, "F"=5), #penality of occupational area: low, other sites can cam close
  rob_birth=c("HG"=0.3, "F"=0.5), #proba of giving birth every year
  rob_survive=c("HG"=0.8, "F"=0.65), #proba of dying when pop > K
  rob_split=c("HG"=0.5, "F"=0.6), #proba of creating a new settlement when Ne > K
  inimals=c("HG"=0.14,"F"=0.20), #how big the group of migrant should be to create a new city vs migrate to a existing one 
  ufferatack=300, #distance max around which settlement can fight
  rob_move=c("HG"=0.2, "F"=0.1) #proba of migrating to existing settlement when Ne > K
)
```

```{r, echo=FALSE, message=FALSE}
a = knitr::spin('../../R/run_simulation.R', format='Rmd', comment=c("#'","#'"),
            precious=TRUE, knit=FALSE, report=FALSE)
fs::file_move('../../R/run_simulation.Rmd', '.')
```

Check the code of the simulation functions here:
<details><summary>Show code</summary>
**Code**
```{r, echo=FALSE, results='asis'}
res = knitr::knit_child(input='run_simulation.Rmd', quiet=TRUE)
cat(res, sep = '\n')
fs::file_delete('run_simulation.Rmd')
```
</details>


The list `onesimu`  contains a few interesting info:


```{r,cache=F}
Nts <- onesimu$Nts # population at each timestep
warcasualties <- onesimu$warcasualties #death by war at each time step
```


Use ressource to adjust the Ks:
```{r,eval=T}
plot(sites, cex=(1+Nts[1,]/100), pch=21, bg=rainbow(2, alpha=0.6)[as.factor(sites$culture)])
```


We look at the simulation step by stepk
Step by step to allow interaction between sites:

```{r,eval=T,messages=F}
## Run stochastic process  


#par(mfrow=c(2,1))
i <- ncol(Nts)
plot(1, 1, type="n", xlim=c(0,i), ylim=c(0,max(Nts)), xlab="time", ylab="popsize")
lapply(1:ncol(Nts),
       function(j)lines(Nts[,j],col=rainbow(2)[as.factor(sites$culture)[j]])
)

```

Visualise, Record deposit and  loss. for the 5 first sites (see next chapters for `A_rates`).
```{r,out.width="25%"}
alldeposit <- lapply(
  1:5,
  function(i){
    Rec_c(sapply(Nts[,i], A_rates), InitBP = 15000, ts=ts, r=0.2, max_bone_thickness="m")
  }
)
maxy <- max(sapply(alldeposit, function(i)max(apply(i,2,sum))))

nill <- lapply(alldeposit, function(depo)barplot(t(depo), col=viridis(ts+1), ylim=c(0,maxy)))
```

Population by time and culture

```{r,eval=T}
par(mfrow=c(2,1))
plot(1, 1, type="n", xlim=c(0,i), ylim=c(0,max(Nts)),
     xlab="time", ylab="popsize")
lapply(1:ncol(Nts),
       function(i)lines(Nts[,i], col=rainbow(2)[as.factor(sites$culture)[i]]))
plot(apply(Nts, 1, sum)[1:i], xlab="time", ylab="popsize")

```


Below some useful code to manually select the resource origins on the map (by clicking on the screen) and explore different decays around them

```{r, eval=F}
plotMap(height.ras, height.wat, paste0("year ", 0))
new_site <- vect(as.data.frame(locator()), geom=c("x", "y"))  # select point on the sscreep
crs(new_site) <- crs(height.ras)
d2 <- logisticdecay(new_site, height.ras, x=20000) # generate a logistic decay around the point

plot(d2)
w <- (0.7*d2 + 0.3*ress) / (0.7*minmax(d2)[2] + 0.3*minmax(ress)[2])
plot(w)
plot(mask(w*logisticdecay(new_site, height.ras, k=0.00002, x=1), territory))
multisamp <- sapply(
  1:1000,
  function(i){
    spatSample(x=w, size=1, method="weights", xy=T)[1:2]
  }
)


```

Exploring some trajectories of the simulations

```{r, eval=T}
i <- nrow(Nts)  # Get the number of rows in Nts
plot(apply(Nts[1:i, sites$culture=="F"], 1, sum), col="red", type="l",
     lwd=2, ylim=c(0, max(apply(Nts, 1, sum))))  # Plot sum of 'F' culture values
points(apply(Nts[1:i, sites$culture=="HG"], 1, sum),
       col="blue", lwd=2, type="l")  # Add points for 'HG' culture values
plot(warcasualties[1:(i-1)], lwd=2, col="green", type="h", yaxt="n", ylab="")  # Plot war casualties
axis(4)  # Add an axis on the right side
par(new=T)  # Allow a new plot to be drawn on the existing plot
growF <- apply(Nts[1:(i-1), sites$culture=="F"], 1, sum)  # Sum of 'F' culture values excluding last row
growHG <- apply(Nts[1:(i-1), sites$culture=="HG"], 1, sum)  # Sum of 'HG' culture values excluding last row
plot(growF, col="red", type="l", lwd=2, ylim=c(0, max(growF, growHG)))  # Plot growth of 'F' culture
points(growHG, col="blue", lwd=2, type="l")  # Add points for growth of 'HG' culture
```


