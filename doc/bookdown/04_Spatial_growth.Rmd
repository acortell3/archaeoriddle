# Populatin grow on multiple sites

All the function below are mere illustration, the exact functions, used for the final simulations are in `tools.R`

```{r,eval=F}
## Function 11. Logistic decay
#' @title Logistic decay
#' @param pt a vector point around witch decay is computed
#' @param rast a raster to compute distances
#' @param L starting point of decay
logisticdecay <- function(pt, rast, L = 1, k = 0.0001, x0 = 60000){
  ds <- distance(rast, pt)
  decay <- L-L/(1+exp(-k*(ds-x0)))
  return(decay)
}

## Function 12. Create population matrix
#' @title Create initial population matrix
#' @param n number of individuals
#' @param ages initial ages
#' @param p_sex proportion of the different sex
#' @return a dataframe with age and sex of every individual of the population
initpopstruc <- function(n=100, ages=10:30, p_sex=c(0.5,0.5)){
  data.frame("Age" = sample(ages, n, ages, replace = TRUE),
             "Sex" = sample(c("M", "F"), n, prob=p_sex, replace=TRUE))
}

## Function 13. Create initial list of sites
#' @title Create initial list of sites
#' @param list_sites a list of population for all initial sites of the simulation
#' @param ts length of simulation
initlistsites <- function(list_sites, ts = 200){
  Nts <- matrix(0, nrow=ts + 1, ncol=length(list_sites))
  Nts[1,] <- sapply(list_sites, nrow)
  return(Nts)
}


#
# This should be change by a funciton that allow to:
# sample the existing pop and kill some, swapp between two pop

## Function 14. Samples through an existing population
#' @title Sample through an existing population
#'
#' @param loosingPop population matrix that will loose members
#' @param winingPop population matrix that will gain members (optional)
#' @param size size of moving/killed population
#' @param new 
#' @param method 
#' @param probs Density function to generate probabilities of dying
#' according to age. Default is dnorm with age as quantiles 
#' @param prob.option List with elements `mean` and `sd` to use in the `prob` function
#' @return Updated loosing and winning populations
#' @export
#'
#' @examples
changePopSize <- function(
  loosingPop, winingPop = NULL, size, new = F, method = "random",
  probs = dnorm, prob.option = list("sd"=10, "mean"=22)
  ) {
  #print(dim(loosingPop))
  #if(!is.null(winingPop))
  #    print(dim(winingPop))
  #if(length(size)==0 || size==0)return(data.frame(Age=numeric(),Sex=character()))
  if(nrow(loosingPop)==0){ 
    kill <- 0
  } else if(method=="random"){
    kill <- sample(
      x=1:nrow(loosingPop), size=size,
      prob=probs(
        loosingPop$Age, mean=prob.option$mean, sd=prob.option$sd))
  }
  #print(paste("diff",nrow(popdistrib)-size,"new",size))
  if(!is.null(winingPop)){
    winingPop <- rbind(winingPop, loosingPop[kill, ])
  }
  loosingPop=loosingPop[-kill, ]
  if(!is.null(winingPop)) {
    return(list(loosingPop, winingPop))
  } else {
    return(loosingPop)
  }
}

# ## Function 15. Initial carrying capacity
# #' @param Kbase baseline carrying capacity or different culturesj
# #' @param sites raster with site and culture
# #' @param resources a raster type for fall sites
# initKs <- function(Kbase = c("HG"=30, "F"=120), sites, resources, sizeexp=NULL){
#   Ks <- round( Kbase[sites$culture] + rnorm(length(sites), 0, 10) )
#   while(any(Ks<1)) {
#     Ks <- round( Kbase[sites$culture] + rnorm(length(sites), 0, 10) )
#   }
#   #Ks[sites$culture=="F"]=Ks[sites$culture=="F"]*runif(sum(sites$culture=="F"),1,1)
#   tmp <- Ks*( 1 + extract(resources, sites)[,2] )
#   if(!is.null(sizeexp)){
#     tmp[sites$culture==sizeexp] <- (
#       Ks[sites$culture==sizeexp] *
#         (1 + rexp(sum(sites$culture==sizeexp), rate=.3) *
#           extract(resources, sites[sites$culture==sizeexp])[, 2])
#     )
#   }
#   return(tmp)
# }


initKs <- function(Kbase=c("HG"=30,"F"=120),sites,ressources,sizeexp=NULL){
    Ks=round(Kbase[sites$culture]+rnorm(length(sites),0,10))
    while(any(Ks<1)) Ks=round(Kbase[sites$culture]+rnorm(length(sites),0,10))
    #Ks[sites$culture=="F"]=Ks[sites$culture=="F"]*runif(sum(sites$culture=="F"),1,1)
    tmp=Ks*(1+extract(ressources,sites)[,2])
    if(!is.null(sizeexp))tmp[sites$culture==sizeexp]=Ks[sites$culture==sizeexp]*(1+rexp(sum(sites$culture==sizeexp),rate=.3)*extract(ressources,sites[sites$culture==sizeexp])[,2])
    tmp
}



plotMap <- function(height, water, maintitle=""){
  plot(height^1.9, col=col_ramp(50), legend=F, reset=F, main=maintitle)
  plot(water, col="lightblue", add=T, legend=F)
}


#' @title Check who is touching a given site
#' @param i index of the site checked
#' @param sites raster with site coordinates,  cultures and karying capacityes
#' @param homophily if true, return all sites that touch (even same culture)
#' @param Ne population size of all sites (could be remove if Ne was stored in the raster)
#' @return A list of sites touching site i
#' @export
whotouch <- function(i, sites, homophily=F, buffersize=200, Ne){
  touch <- st_intersects(
    st_make_valid(st_as_sf(buffer(sites[i], Ne[i]*buffersize))),
    st_make_valid(st_as_sf(buffer(sites, Ne*buffersize))))
  # If there are 1 or more sites touching i
  if(length(touch)>0){
    enemies <- unlist(touch)
    if(homophily) {
      enemies <- enemies[enemies!=i]
    } else {
      enemies <- enemies[sites$culture[enemies]!=sites$culture[i]]
    }
  }
  else {
    enemies <- NA
  }
  return(enemies)
}

#' @tile A simple fight between sites
#' A function to compute lost during a fighting.
#' Who's the winner and looser depend on population size
#' Decrease in population size is simply calculated with a binomial and a prob
#' of individual survival for the winner and the looser
#' @param Ne list of population size for the fighting settlement
#' @param a indice of the first settlement
#' @param b indice of the second settlement
#' @return the updated population size of both settlements engaged in the fight
simplefight <- function(Ne, a, b){
  # Compute who wins randomly, but based on population sizes
  if(runif(1)<Ne[a]/(Ne[a]+Ne[b])){
    v <- a
    l <- b
  }
  else{
    v <- b
    l <- a
  }
  one <- Ne
  Ne[v] <- rbinom(n=1, prob=.9, size=Ne[v])
  Ne[l] <- rbinom(n=1, prob=.4, size=Ne[l])
  print(
    paste(
      "victory", v, "(", one[v], "-", Ne[v], ") over",
      l,"(", one[l], "-", Ne[l], "), total of:",
      (one[v]-Ne[v]) + (one[l]-Ne[l]), "people"))
  return(Ne)
}   


#' @tile A simple fight between sites
#' A function to compute lost during a fighting.
#' Who's the winner and looser depend on population size.
#' Decrease in population size is simply calculated with a binomial and a prob
#' of individual survival for the winner and the looser. The probabilities depend
#' on the the relative population size of each size.
#' @param Ne list of population size for the fighting settlement
#' @param a indice of the first settlement
#' @param b indice of the second settlement
#' @return the updated population size of both settlements engaged in the fight
fightbetterloss <- function(Ne,a,b){
  if (runif(1)<Ne[a]/(Ne[a]+Ne[b])) {
    v=a
    l=b
  }
  else{
    v=b
    l=a
  }
  one <- Ne
  Ne[v] <- rbinom(n=1, prob=1-Ne[l]/(Ne[v] + Ne[l]), size=Ne[v])
  Ne[l] <- rbinom(n=1, prob=1-Ne[v]/(Ne[v] + Ne[l]), size=Ne[l])
  print(
    paste(
      "victory", v, "(", one[v], "-", Ne[v], ") over",
      l, "(", one[l], "-", Ne[l], "), total of:",
      (one[v]-Ne[v]) + (one[l]-Ne[l]), "people"))
  return(Ne)
}   


##draw a war symbole where two clans are fighting
warpoints <- function(sites, a, b, Ne, buffersize=300, plot=T, sizewar=2) {
    meetpoints <- crop(
      buffer(sites[a], 1+Ne[a]*buffersize),
      buffer(sites[b], 1+Ne[b]*buffersize)
    )
    if (length(meetpoints)>0) {
      p <- spatSample(meetpoints,1)
      if (plot & length(p)>0) {
        plot(p, add=T, bg="red", pch="üî•", cex=sizewar,
             col=adjustcolor("yellow", 0.1))
        
        plot(p, add=T, bg="yellow", pch="‚öîÔ∏è",cex=sizewar)
      }
      return(p)
    } else NULL
}


run_simulation <- function(cultures=NULL,
                           sites=sites,
                           dem=height.ras,
                           ressources=ress,
                           water=height.wat,
                           foldervid="pathtofinal",
                           visu=F,visumin=TRUE,
                           ts=20000,#length of simulation in year
                           Kbase=c("HG"=35,"F"=120),#difference in K for the two cultures
                           cul_ext=c("HG"=7,"F"=6),#spatial penality to extent: lower, bigger penality
                           penal_cul=c("HG"=4,"F"=5),#penality of occupational area: low, other sites can cam close
                           prob_birth=c("HG"=0.3,"F"=0.5),#proba to give birth every year
                           prob_survive=c("HG"=0.8,"F"=0.6),#proba to die when pop > K
                           prob_split=c("HG"=.2,"F"=.6),#proba to create new settlement when Ne > K
                           minimals=c("HG"=.14,"F"=.20),#how big the group of migrant should be to create a new city vs migrate to a existing one 
                           bufferatack=400,#distance max around which settlement can fight
                           buffersettl=2000,#distance min around which settlement cannnot settle
                           prob_move=c("HG"=0.2,"F"=0.1) #proba to migrate to existing settlement when Ne > K
                           ){
    ## Run stochastic process  

    Ks=sites$Ks
    cultures=sites$culture
    INs=round(runif(length(sites),.85,.95)*sites$Ks) #Population size at initialisation


    Ips <- lapply(INs,initpopstruc ) #initialise population structure for all sites

    Nts=initlistsites(Ips,ts=ts)
    ### visualisation =====
    frame=0
    if(!dir.exists(foldervid))dir.create(foldervid)
    ###

    warcasualties=vector("integer",ts)

    for (i in 2:(ts+1)){
        print(paste("year",i,"total",sum(sapply(Ips,nrow)),"with",length(sites),"sites"))
        print(table(sites$culture[Nts[i-1,]>0]))
        if(visumin){
            ### visualisation =====
            frame=frame+1
            filename=sprintf("map_%06d.png", frame)
            png(file.path(foldervid,filename),width=800,height=800,pointsize=20)
            plotMap(dem,water,paste0("year ",i))
            ########
        }
        inactives=(Nts[i-1,]==0)
        for(s in sample(seq_along(sites)[!inactives])){

            if(visu){
                ### visualisation =====
                frame=frame+1
                filename=sprintf("map_%08d.png", frame)
                png(file.path(foldervid,filename),width=800,height=800,pointsize=20)
                plotMap(dem,water,paste0("year ",i))
                ########
            }

            city=NULL
            Ips[[s]] <- Gpd(Ips[[s]], K = Ks[[s]], p_offspring=prob_birth[sites$culture[s]],prob = prob_survive[sites$culture[s]] ) #compute new population for the sites
            newN=nrow(Ips[[s]]) #count population size

            if(newN>=(Ks[[s]])){ #if new population is more than carrying capacity: migration scenario
                migrants=newN-round(Ks[[s]]*0.9)
                ##Creation of new city
                new_site=NULL
                #if(sites$culture[s]=="F")print(paste("possib",migrants, (minimals[sites$culture[s]]*sites$Ks[s])))
                tmp=Nts[i-1,]
                tmp[Nts[i,]>0]=Nts[i,Nts[i,]>0]
                #tmp=tmp+sqrt(sites$Ks)
                havemoved=F

                if(migrants>= (minimals[sites$culture[s]]*sites$Ks[s]) & runif(1)<prob_split[sites$culture[s]] ){ #if supropulation > 10 people, 10% chance of creation of a new city

                    #print(paste("look for new spot for ",migrants, "from site",s,"culture",sites$culture[s]))
                    buffersize=(sqrt(tmp)+penal_cul[cultures])*buffersettl*runif(1,.5,1.5)
                    buffersize[tmp==0]=0
                    territory=erase(viable,buffer(sites,buffersize))

                    if(length(territory)>0){
                        #print(paste("found new spot",migrants))

                        ##select a new site given its distance to the old one and the resourcesource available in resources
                        d2=logisticdecay(sites[s],dem,x=20000*cul_ext[sites$culture[s]])
                        w=(.7*d2+.3*resources)/(.7*minmax(d2)[2] + .3*minmax(resources)[2])
                        new_site=spatSample(x=mask(w*logisticdecay(sites[s],dem,k=0.00002,x=20000*cul_ext[sites$culture[s]]),territory),size=1,method="weights",xy=T)[1:2]
                        new_site=vect(new_site,geom=c("x","y"))

                        if(length(new_site)>0 & all(!is.na(crds(new_site)))){
                            ##add new site to site listes
                            ##initialise population struc of new site
                            #print(paste("total sites:",length(Ips)))
                            #print(paste("dim Nts:",dim(Nts)[2]))
                            #print(paste("site sf Nts:",length(sites)))

                            Ips[[length(Ips)+1]]=initpopstruc(n=migrants) #initialise a fake populaition, will be updated by real migrants later
                            new_site$culture=sites$culture[s]
                            new_site$Ks=round(initKs(Kbase,sites=new_site,resources,sizeex="F"))
                            print(paste0("new settlement (",sites$culture[s],") of K ",new_site$Ks, " and pop ",migrants))

                            sites=rbind(sites,new_site)

                            Ks[length(Ks)+1]=new_site$Ks
                            city=(length(Ips))
                            Nts=cbind(Nts,rep(0,ts+1))
                            Nts[i,city]=migrants
                            cultures=c(cultures,cultures[s])
                            #print(paste("new site sf Nts:",length(sites)))
                            #print(paste("new dim Nts:",dim(Nts)[2]))
                            #print(paste("new total sites:",length(Ips)))
                            havemoved=T
                        }
                    }
                }
                ## if no creation of new city happen, there is a certain probability that people will move
                if(length(new_site)==0 && runif(1)<prob_move[sites$culture[s]] ){

                    #getj
                    att=extract(resources,sites)[,2]
                    space=sites$Ks-(Nts[i-1,]+migrants)
                    dis=extract(logisticdecay(sites[s],dem,k=0.00002,x=1),sites)[,2]
                    attractivity=att*space*dis
                    attractivity=attractivity*(1+10*(sites$culture[s]==sites$culture)) #4 times more likely to go to similar culture
                    attractivity[s]=min(attractivity)-1
                    attractivity=exp(attractivity)/sum(exp(attractivity))
                    attractivity[Nts[i-1,]<10]=0 
                    attractivity[sites$culture!=sites$culture[s]]=0 
                    city=sample(size=1,x=seq_along(sites),prob=attractivity)
                    Nts[i,city]=Nts[i-1,city]+migrants
                    print(paste("migration from",sites$culture[s],"to",sites$culture[city]))
                    havemoved=T
                }
                if(havemoved){

                    #print(paste("old spot",migrants," for ",nrow(Ips[[s]])))
                    #print(paste("old new spot",migrants," for ",nrow(Ips[[city]])))

                    #if(city>length(Ips))print(paste("problem, migrants:",migrants))
                    #print(paste("the other:",city))
                    Ips[c(s,city)]=changePopSize(loosingPop=Ips[[s]],winingPop=Ips[[city]],size=migrants)
                    newN=newN-migrants
                    #print(paste("loosing ",newN," vs ",nrow(Ips[[s]])))
                    #print(paste("wining ",newN," vs ",nrow(Ips[[city]])))
                }

            }
            Nts[i,s]=newN


            if(visu){
                ###visualisation=========
                sitescols=rep(1,length(sites))
                siteslwd=rep(1,length(sites))
                ii=NULL
                if(!is.null(city)){
                    sitescols[s]="yellow"
                    sitescols[city]="red"
                    siteslwd[s]=3
                    siteslwd[city]=3
                    ii=st_cast(st_combine(st_as_sf(sites[c(s,city)])),"LINESTRING")
                }
                if(!is.null(ii))plot(ii,add=T)
                tmp=Nts[i-1,]
                tmp[Nts[i,]>0]=Nts[i,Nts[i,]>0]
                plot(sites,cex=(as.integer(Nts[i,]>0)*0.3+Nts[i,]/200),pch=21,add=T,bg=rainbow(2,alpha=.6)[as.factor(sites$culture)],lwd=siteslwd,col=sitescols)
                dev.off()
                ###=======================
            }
        }
        if(visumin){
            plot(sites,cex=(as.integer(Nts[i,]>0)*0.3+Nts[i,]/200),pch=21,add=T,bg=rainbow(2,alpha=.6)[as.factor(sites$culture)])
        }
        for(s in sample(which(sites$culture=="F" & Nts[i,]>0))){
            buff=bufferatack
            clash=whotouch(s,sites,Ne=Nts[i,],buffersize=buff)
            if(length(clash)>0 && !is.na(clash) && runif(1)<.1){
                clash=clash[Nts[i,clash]>0]
                if(length(clash)==1)attack=clash
                else attack=sample(clash,1)
                newns=fightbetterloss(Ne=Nts[i,],a=s,b=attack)
                casualties=sum(Nts[i,c(s,attack)]-newns[c(s,attack)])
                warcasualties[i]=casualties
                sizew=casualties^2/4000
                warpoints(sites,s,attack,Ne=Nts[i,],buffersize=buff,sizewar=sizew+.5)

                print(paste0(s," (",cultures[s],") with ",Nts[i,s]," individual, attacks: ",attack," (",cultures[attack],") with ",Nts[i,attack]," individual, #casualties=",casualties))

                #effectively kill people in population (should be done taking into account age pyramid to be more realistic)
                Ips[[s]]=changePopSize(loosingPop=Ips[[s]],size=(Nts[i,s]-newns[s]))
                Ips[[attack]]=changePopSize(loosingPop=Ips[[attack]],size=(Nts[i,attack]-newns[attack]))
                Nts[i,]=newns
                print(paste0("fight : #", s," (",cultures[s],") left with ",Nts[i,s]," (bef:",Nts[i-1,s],") ind., attacked: #",attack," (",cultures[attack],") with ",Nts[i,attack]," (bef:",Nts[i-1,attack],") ind., #death=",casualties))
            }
        }
        if(visumin)dev.off()
    }
    return(list(Nts=Nts,warcasualties=warcasualties,Ips=Ips,sites=sites))
}


```


## Environmental resources
We generate zone of hight resource, that will attract settlements and support higher K

```{r}

source("tools.R")
##ressource geolocalisation set manually
goodresources=vect(
                    cbind(
                     x=c(-0.2300711,-3.1455282,-0.5086485,-1.9639755,-0.4077843,0.019688,-3.116710),
                     y=c(3.6423000,-0.2551019,-0.7440748,1.1303214,1.0248567,0.2194895,2.0267718)
                     )
                    )
#spread of resources
areas=4*c(100,2000,200,300,100,200,400)
#speed of ressource decay:
ks=c(0.0002,0.0001000,0.0001600,0.0001800,0.00040,.0002,0.0002)/4

crs(goodresources)=crs(height.ras)

allres=lapply(seq_along(goodresources),function(i)logisticdecay(goodresources[i],mask(height.ras,viable),x=areas[i],k=ks[i]))

allna=sapply(allres,function(i)any(is.na(values(i))))
allres=allres[!allna]

ress=allres[[1]]
for(i in 2:length(allres))
    ress=ress+allres[[i]]
ress=mask(ress,viable)
plot(ress)
```
## Initial sites and size:

```{r,eval=T}
#a manual way to set cultures given general geography
cultures=rep("HG",length(sites))
cultures[(crds(sites)[,"x"] < -1 & crds(sites)[,"y"] < 1)]="F"
sites$culture=cultures
Kbase=c("HG"=45,"F"=120) #difference in K for the two cultures
sites$Ks=initKs(Kbase,sites,ress,sizeexp="F")
#saveRDS(file="testsites.RDS",sites)
```

Now we have sites with two cultures, initialise the parameters we will use:

```{r}

#(read sites saved before)
# sites=readRDS(file="testsites.RDS",sites)


#initialisation

ts=250
Kbase=c("HG"=45,"F"=120) #difference in K for the two cultures
cul_ext=c("HG"=7,"F"=6) #spatial penality to extent: lower, bigger penality
penal_cul=c("HG"=4,"F"=5) #penality of occupational area: low, other sites can cam close
prob_birth=c("HG"=0.3,"F"=0.5) #proba to give birth every year
prob_survive=c("HG"=0.8,"F"=0.6) #proba to die when pop > K
prob_split=c("HG"=.2,"F"=.6) #proba to create new settlement when Ne > K
minimals=c("HG"=.14,"F"=.20) #how big the group of migrant should be to create a new city vs migrate to a existing one 
prob_move=c("HG"=0.2,"F"=0.1) #proba to migrate to existing settlement when Ne > K

height.wat=height.ras
height.wat[height.wat>mean(height.wat[])]=NA
height.groups=height.ras
maxh=max(height.ras[],na.rm=T)
height.groups[height.groups<mean(height.groups[])]=NA
height.groups[height.groups<(maxh*.7)]=1
height.groups[height.groups>(maxh*.7)]=200
height.groups[is.na(height.groups)]=-1
height.poly=as.polygons(height.groups)
viable=makeValid(height.poly[2,])
plotMap(height.ras,height.wat,paste0("year ",0))
plot(sites,pch=21,add=T,bg=rainbow(2,alpha=.6)[as.factor(sites$culture)])
text(sites)
```

We can run a simple simulations using this:


```{r,eval=T}


onesimu=run_simulation (
                           sites=vect("data_original/sitesinitialposition/"),
                           dem=rast("data_original/east_narnia4x.tif"),
                           ressources=rast("data_original/resources.tiff"),
                           water=height.wat,
                           foldervid="tests",
                           visu=T,visumin=TRUE,
                           ts=150,#length of simulation in year
                           Kbase=c("HG"=35,"F"=120),#difference in K for the two cultures
                           cul_ext=c("HG"=7,"F"=6),#spatial penality to extent: lower, bigger penality
                           penal_cul=c("HG"=4,"F"=5),#penality of occupational area: low, other sites can cam close
                           prob_birth=c("HG"=0.3,"F"=0.5),#proba to give birth every year
                           prob_survive=c("HG"=0.8,"F"=0.6),#proba to die when pop > K
                           prob_split=c("HG"=.4,"F"=.6),#proba to create new settlement when Ne > K
                           minimals=c("HG"=.14,"F"=.20),#how big the group of migrant should be to create a new city vs migrate to a existing one 
                           bufferatack=400,#distance max around which settlement can fight
                           prob_move=c("HG"=0.2,"F"=0.1) #proba to migrate to existing settlement when Ne > K
                           )
```

The list `onesimu`  contains a few interesting info:


```{r,cache=F}
Nts <- onesimu$Nts # population at each timestep
warcasualties <- onesimu$warcasualties #death by war at each time step
```


Use ressource to adjust the Ks:
```{r,eval=T}
plot(sites,cex=(1+Nts[1,]/100),pch=21,bg=rainbow(2,alpha=.6)[as.factor(sites$culture)])
```


We look at the simulation step by stepk
Step by step to allow interaction between sites:

```{r,eval=T,messages=F}
## Run stochastic process  


#par(mfrow=c(2,1))
i=ncol(Nts)
plot(1,1,type="n",xlim=c(0,i),ylim=c(0,max(Nts)),xlab="time",ylab="popsize")
lapply(1:ncol(Nts),function(j)lines(Nts[,j],col=rainbow(2)[as.factor(sites$culture)[j]]))

```

Visualise, Record deposit and  loss. for the 5 first sites
```{r,out.width="25%"}
alldeposit=lapply(1:5,function(i)Rec_c(sapply(Nts[,i],A_rates), InitBP = 15000,ts=ts,r = 0.2, Max_bone_thickness = "m"))
maxy=max(sapply(alldeposit,function(i)max(apply(i,2,sum))))

nill=lapply(alldeposit,function(depo)barplot(t(depo),col=viridis(ts+1),ylim=c(0,maxy)))
```

Population by time and culture

```{r,eval=T}
par(mfrow=c(2,1))
plot(1,1,type="n",xlim=c(0,i),ylim=c(0,max(Nts)),xlab="time",ylab="popsize")
lapply(1:ncol(Nts),function(i)lines(Nts[,i],col=rainbow(2)[as.factor(sites_new$culture)[i]]))
plot(apply(Nts,1,sum)[1:i],xlab="time",ylab="popsize")

```


Below some code  to manually select the ressource origins on the map and explore differenet devay around them
```{r,eval=F}
plotMap(height.ras,height.wat,paste0("year ",0))
new_site=vect(as.data.frame(locator()),geom=c("x","y"))  # select point on the sscreep
crs(new_site)=crs(height.ras)
d2=logisticdecay(new_site,height.ras,x=20000) # generate a logistic decay around the point

plot(d2)
w=(.7*d2+.3*ress)/(.7*minmax(d2)[2] + .3*minmax(ress)[2])
plot(w)
plot(mask(w*logisticdecay(new_site,height.ras,k=0.00002,x=1),territory))
multisamp=sapply(1:1000,function(i)spatSample(x=w,size=1,method="weights",xy=T)[1:2])


```

Exploring some trajectories of the simulations

```{r,eval=T}
i=nrow(Nts)
plot(apply(Nts[1:i,sites_new$culture=="F"],1,sum),col="red",type="l",lwd=2,ylim=c(0,max(apply(Nts,1,sum))))
 points(apply(Nts[1:i,sites_new$culture=="HG"],1,sum),col="blue",lwd=2,type="l")
plot(warcasualties[1:(i-1)],lwd=2,col="green",type="h",yaxt="n",ylab="")
axis(4)
par(new=T)
growF=apply(Nts[1:(i-1),sites_new$culture=="F"],1,sum)
growHG=apply(Nts[1:(i-1),sites_new$culture=="HG"],1,sum)
plot(growF,col="red",type="l",lwd=2,ylim=c(0,max(growF,growHG)))
 points(growHG,col="blue",lwd=2,type="l")
```

Population density:

overal: .7 

or: >1 and 1.2 for Farmers
or: <1  for Hunter Gather

HG: 0.08 - 0.16


