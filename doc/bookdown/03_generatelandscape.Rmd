# Landscape and climate

Let's Create a fake environment

```{r function_autocorel}

#' From tuneR package (implemented in the file Waveforms.R in tuneR source)
#'
#' Based on Timmer and Koening 1995: https://ui.adsabs.harvard.edu/abs/1995A\%26A...300..707T/abstract
#'
#' @param alpha: the slope of the power distribution (called omega in whitehead)
#' @param N: the length of the timeserie to generate
#' @export
TK95 <- function(N, alpha = 1){ 
    f <- seq(from=0, to=pi, length.out=(N/2+1))[-c(1,(N/2+1))] # Fourier frequencies
    f_ <- 1 / f^alpha # Power law
    RW <- sqrt(0.5*f_) * rnorm(N/2-1) # for the real part
    IW <- sqrt(0.5*f_) * rnorm(N/2-1) # for the imaginary part
    fR <- complex(real = c(rnorm(1), RW, rnorm(1), RW[(N/2-1):1]), 
                  imaginary = c(0, IW, 0, -IW[(N/2-1):1]), length.out=N)
     # Those complex numbers that are to be back transformed for Fourier Frequencies 0, 2pi/N, 2*2pi/N, ..., pi, ..., 2pi-1/N 
     # Choose in a way that frequencies are complex-conjugated and symmetric around pi 
     # 0 and pi do not need an imaginary part
    reihe <- fft(fR, inverse=TRUE) # go back into time domain
    return(Re(reihe)) # imaginary part is 0
}

#return spectrum of a timeserie
#' @export
getSpectrum <- function(x){
	N <- length(x)
    pw=8
	M <- 2^pw # zero-pad total length
    while(M<N){
        pw=pw+1
        M <- 2^pw
    }
	freq <- seq(0, 0.5, by = 1/M)
	x.zp <- c(x, rep(0, M-N))
	S.pgram <- (1/N)*abs(fft(x.zp)[1:(M/2+1)])^2
    S.pgram
}

#' Environment generator
#'
#' return a list of opitmum as a "1/f-noise" of N steps with sd = delta and the slope of it's spectrum decompoistion = -omega + possibility to increase the mean of the environment at a rate vt (in wich case the slop may not be -omega)
#'
#' @param omega the slope of the power distribution (called omega in whitehead)
#' @param delta the standard deviation of the global environmental fluctuation 
#' @param N the length of the timeserie to generate
#' @param vt if not NULL, the  mean of the optimum increase at a rate vt  
#' @return a list of N optima theta
#' @export
environment <- function(N,omega,delta,vt=NULL){
    ts=TK95(N,omega)
    ts=delta*ts/sd(ts)
    if(!is.null(vt))ts = ts + vt*1:N
    return(ts)
}

# white noise
#' @export
gauss <- function(N,mean,delta,v){
    sapply(1:N,function(t)rnorm(1,mean*v,delta))
}


```

To generate a fake climate with various properties:


```{r generateFakeClimate}
tstep=1000
faketemp=environment(tstep,omega=3,delta=1.5)+1.5
plot(faketemp,type="l",ylab="temperature change",xlab="time")   
```

Generate a 2D landscape using perlin noise cf [this post](https://stackoverflow.com/questions/15387328/realistic-simulated-elevation-data-in-r-perlin-noise)

```{r perlinnoise}
#install.packages(c("terra","sf"))
library(terra)
library(sf)

perlin_noise <- function( 
  n = 5,   m = 7,    # Size of the grid for the vector field
  N = 100, M = 100   # Dimension of the image
) {
  # For each point on this n*m grid, choose a unit 1 vector
  vector_field <- apply(
    array( rnorm( 2 * n * m ), dim = c(2,n,m) ),
    2:3,
    function(u) u / sqrt(sum(u^2))
  )
  f <- function(x,y) {
    # Find the grid cell in which the point (x,y) is
    i <- floor(x)
    j <- floor(y)
    stopifnot( i >= 1 || j >= 1 || i < n || j < m )
    # The 4 vectors, from the vector field, at the vertices of the square
    v1 <- vector_field[,i,j]
    v2 <- vector_field[,i+1,j]
    v3 <- vector_field[,i,j+1]
    v4 <- vector_field[,i+1,j+1]
    # Vectors from the point to the vertices
    u1 <- c(x,y) - c(i,j)
    u2 <- c(x,y) - c(i+1,j)
    u3 <- c(x,y) - c(i,j+1)
    u4 <- c(x,y) - c(i+1,j+1)
    # Scalar products
    a1 <- sum( v1 * u1 )
    a2 <- sum( v2 * u2 )
    a3 <- sum( v3 * u3 )
    a4 <- sum( v4 * u4 )
    # Weighted average of the scalar products
    s <- function(p) 3 * p^2 - 2 * p^3
    p <- s( x - i )
    q <- s( y - j )
    b1 <- (1-p)*a1 + p*a2
    b2 <- (1-p)*a3 + p*a4
    (1-q) * b1 + q * b2
  }
  xs <- seq(from = 1, to = n, length = N+1)[-(N+1)]
  ys <- seq(from = 1, to = m, length = M+1)[-(M+1)]
  outer( xs, ys, Vectorize(f) )
}


a <- .6
k <- 8
m <- perlin_noise(2,2,2^k,2^k)
for( i in 2:k )
  m <- m + a^i * perlin_noise(2^i,2^i,2^k,2^k)
plot(rast(m))
```


Tweak a bit the perlin noise to have more difference between low area and high area and make it more "DEM" looking

```{r padjuperlin}
height=(m[,])*20
#height[height<50]=0
height=height^3
height=height+abs(mean(height))
height[height<min(height)*.25]=min(height)*.25
```

Rayshader play

```{r threedim,eval=T}
library(vctrs)
library(rayshader)
height_map = raster_to_matrix(raster::raster(height)) 

hm_shade <-  sphere_shade(height_map,texture = "imhof1",zscale=5) 
hm_ray  <-  add_shadow(hm_shade,ray_shade(height_map, zscale = 19), 0.8) 
hm_ambiant  <- add_shadow(hm_ray,ambient_shade(height_map), 0,5) 
hm_lamb = add_shadow(hm_ambiant,lamb_shade(height_map), 0) 
plot_3d(hm_lamb,height_map, zscale = 10, fov = 0, theta = 20, zoom = 1, phi = 45, windowsize = c(1000, 800),water = TRUE, waterdepth = mean(height), wateralpha = 1, watercolor = "lightblue", waterlinecolor = "lightblue", waterlinealpha = .7,baseshape="hex")

render_highquality( samples=256, clear = TRUE,light=TRUE)

```

Visual the map as a simple 2D raster


```{r 2dVisu}

height.ras=rast(height,extent=c(-2,-1,1,2),crs="+proj=latlon")
maxh=max(height.ras[],na.rm=T)
col_ramp <- colorRampPalette(c("#54843f", "grey", "white"))

plot(height.ras^1.9,col=col_ramp(20),legend=F,reset=F)
height.wat=height.ras
height.wat[height.wat>mean(height.wat[])]=NA
plot(height.wat,col="lightblue",add=T,legend=F)

```

Generate sites in specific location (not on mountains, not in water) with exponentially distributed size and make a network out of it.  



```{r splitArea}
n=10
size=rexp(n)

height.groups=height.ras
height.groups[height.groups<mean(height.groups[])]=NA
height.groups[height.groups<(maxh*.7)]=1
height.groups[height.groups>(maxh*.7)]=200
height.groups[is.na(height.groups)]=-1
height.poly=as.polygons(height.groups)
viable=height.poly[2,]

sites=spatSample(viable,n)

plot(height.ras^1.9,col=col_ramp(50),legend=F,reset=F)
plot(height.wat,col="lightblue",add=T,legend=F)
plot(sites,cex=2,pch=21,add=T,bg=rainbow(n,alpha=.6))
```

Use sites to create a network

```{r sitesnetwork}

library(igraph)
crs(sites)="+proj=lonlat"
ig=graph_from_adjacency_matrix(as.matrix(distance(sites)),weighted=T,mode="undirected")
ig=set_graph_attr(ig,"layout",crds(sites))

V(ig)$label=""
V(ig)$size=(size+1)
V(ig)$frame.color="black"
V(ig)$frame.width=.5
E(ig)$weight=1/(E(ig)$weight^2)
E(ig)$width=(exp(E(ig)$weight)+.6)

allcomu=cluster_louvain(ig)$memberships[1,]
V(ig)$color=allcomu
E(ig)$color=allcomu[head_of(ig,E(ig))]

plot(height.ras^1.9,col=col_ramp(50),legend=F,reset=F)
plot(height.wat,col="lightblue",add=T,legend=F)
plot(ig,add=T,rescale=F)
```

Visualise sites on the 3D plot

```{r 3Dnetwork,eval=T}

plot_3d(hm_lamb,height_map, zscale = 20, fov = 0, theta = 20, zoom = 1, phi = 45, windowsize = c(1000, 800),water = TRUE, waterdepth = mean(height), wateralpha = 1, watercolor = "lightblue", waterlinecolor = "lightblue", waterlinealpha = .7)

render_points(extent = raster::extent(raster::raster(height.ras)),
             lat = crds(sites)[,"y"], long = crds(sites)[,"x"], altitude =extract(height.ras,sites)[,2]+20,
             zscale=20,size=1,col=categorical_pal(max(allcomu))[allcomu],clear_previous = TRUE)
       
render_highquality(point_radius=5,samples=256, clear = TRUE,light=TRUE)

```

let's say the climate modulate site size in a naive way:


```{r,animation.hook="gifski",interval=0.2,cache=TRUE,eval=F}
for(i in seq(1,tstep,length.out=100)){
	layout(matrix(1:2,nrow=2,ncol=1),heights=c(.8,.2))
	par(mar=c(1,2,2,1))
	image(m,ann=F,axes=F,main=i)
	mtext(round(i),3,1)
	nsize=size*faketemp[i]+size+1
	points(crds(sites),bg="green",pch=21,cex=nsize)
	par(mar=c(2,2,0,1))
	plot(1:tstep,faketemp,type="l",ylab="temp",xlab="time",ylim=range(faketemp),ann=F,frame.plot=F)
	points(i,faketemp[i],col="red",pch=20)
}
```


