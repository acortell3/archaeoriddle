---
output:
  pdf_document: default
  html_document: default
  always_allow_html: true
---

# Record formation

## Theoretical model
We have produced a computational model, replicating the process of formation of the archaeological record in a specific site, accounting for different variables. In order to consider the possible relation between those variables, we have decided to express them as a Directed Acyclic Graph (DAG), following the ECS-DAG methodology proposed by Ferguson et al. (2020). In this case, however, and because our goal is to obtain an accurate initial template for the development of the model, we have not considered setting an exposure variable, but rather to propose different theoretic directional and causal relationships without relying on the conventional exposure-outcome assessment. Therefore, highlights in the graph below do not intend to differentiate among confounders, mediators, etc., but to emphasize the possible weight that each variable has for producing the outcome (produced waste by $m^2$).

```{r, echo = FALSE}
library(DiagrammeR)

grViz("
digraph record_formation {

graph [layout = dot, ## Set title and layout
       label = 'Record formation process',
       labelloc = 't'
       fontname = Helvetica,
       fontsize = 30]

# node definitions with substituted label text
node [fontname = Helvetica, ## General node definition
      style = filled,
      color = MistyRose]
      
## Per node definition
a [label = '@@1',
   fillcolor = cadetblue3]
b [label = '@@2',
   fillcolor = cadetblue1]
c [label = '@@3',
   fillcolor = cadetblue3]
d [label = '@@4',
   fillcolor = cadetblue1]
e [label = '@@5',
   fillcolor = cadetblue3]
f [label = '@@6',
   fillcolor = cadetblue,
   fixedsize = shape,
   width = 4.5,
   height = 1,
   fontsize = 30]

## General edge definition
edge [color = grey,
       arrowhead = vee,
       arrowtail = vee]

## Specific edges
a -> {c}
b -> {c}
c -> {f}
d -> {e}
e -> {f}
}

## Label definition
[1]: 'Pop (group size)'
[2]: 'Site function'
[3]: 'Anthropogenic deposition rates'
[4]: 'Site type'
[5]: 'Natural deposition rates'
[6]: 'Waste/sqrm'

")

```

The above graph depicts a very schematic way to represent the formation of the archaeological record ($W/m^2$). In this case, we are interested in radiocarbon dating, focusing on bone samples; that is the number (and range) of potential 14C dates produced in a site, and this is key to understand the way in which we produced the model. We are aware that generating a specific archaeological palimpsest depends on a large quantity of variables, some of which may be controlled by field archaeologists and some of which may not (or are not). Therefore, the graph above must be read as follows. Asides from the outcome variable, the exposure variables, *Pop (group size)*, *Anthropogenic deposition rates* and *Natural deposition rates* (depicted in orange), are designed in a way that they can be activated for the model to infer them, they can be provided by the archaeologist, or they can be simply ignored. In the most elementary case, the archaeologist could introduce directly the outcome variable ($W/m^2$) without taking into account anything else, if she/he is confident to provide an accurate value.

However, in most cases, this information will not be known to the field researcher, and in this situation, this variable can be modelled to different extents of complexity. While. For example, in the case of the most simple simulation, the field archaeologist could ignore deposition rates. In this case, and because we are only considering 14C dates, then the quantity of the sample becomes broadly proportional to the number of people present in a site, and thus it could be modelled like this.

```{r, echo = FALSE, out.width="50%"}
grViz("
digraph record_formation {

graph [layout = dot, ## Set title and layout
       label = 'Record formation process',
       labelloc = 't'
       fontname = Helvetica,
       fontsize = 30]

# node definitions with substituted label text
node [fontname = Helvetica, ## General node definition
      style = filled,
      color = MistyRose]
      
## Per node definition
a [label = '@@1',
   fillcolor = cadetblue3]
b [label = '@@2',
   fillcolor = cadetblue,
   fixedsize = shape,
   width = 4.5,
   height = 1,
   fontsize = 30]

## General edge definition
edge [color = grey,
       arrowhead = vee,
       arrowtail = vee]

## Specific edges
a -> {b}
}

## Label definition
[1]: 'Pop (group size)'
[2]: 'Waste/sqrm'

")

```

However, deposition rates are difficult to ignore if we want to account for the formation process of the archaeological record. If these are known to the archaeologists that developed fieldwork, then this would be the behaviour of the model for creating $W/m^2$.

```{r, echo = FALSE, out.width="60%"}
grViz("
digraph record_formation {

graph [layout = dot, ## Set title and layout
       label = 'Record formation process',
       labelloc = 't'
       fontname = Helvetica,
       fontsize = 30]

# node definitions with substituted label text
node [fontname = Helvetica, ## General node definition
      style = filled,
      color = MistyRose]
      
## Per node definition
a [label = '@@1',
   fillcolor = cadetblue3]
b [label = '@@2',
   fillcolor = cadetblue3]
c [label = '@@3',
   fillcolor = cadetblue,
   fixedsize = shape,
   width = 4.5,
   height = 1,
   fontsize = 30]

## General edge definition
edge [color = grey,
       arrowhead = vee,
       arrowtail = vee]

## Specific edges
a -> {c}
b -> {c}
}

## Label definition
[1]: 'Anthropogenic deposition rates'
[2]: 'Natural deposition rates'
[3]: 'Waste/sqrm'

")

```

Finally, if these are not known to the archaeologist, but she/he wants to model them, then we would go back to the first DAG. In this case, keep reading for the specificities of the model.

This is how each variable works specifically:

* **Waste produced** ($W/m^2$ or just $W$) **(outcome variable)**: Archaeological record present per $m^2$. Since we are considering C14 dates coming from bone, this is the quantity of C14 samples present a time *t* and at a depth *d*. Thus, this variable depends on time and depth. 

$$W(t,d)=function(t,d)$$. 

We have considered this a discrete variable (number of potential samples) with range $[0,\propto K]$. *Defined in code as* `W`.

The variables time ($T$) and depth ($D$) must also be defined. Thus

* **T** describes the time, in years, of existence of the site. For the simulation, this time will be known. Thus, in the simulation $T_{birth}=(T=0)$ and $T_{max}=T_{death}$. Values of $T$ are represented by $t$.
* **D** is the depth, in cms, where each specific sample is deposited at a time $t$. This is a continuous variable with range $[0,\infty]$, and for any $t$, we know that $0\leq D(t)\leq d_0$ and that 

$$D(t)=max\{D(t-1)-r,0\}, t=1,2,...,T_{max}$$

Where $r$ is the deposition rates.

* **Population (group size)** ($P$): Discrete variable with range $[0,\sim K]$. Population group size is key to determine anthropogenic deposition rates (which in turn determine $W$) but it can also be used as a proxy to determine $W$ in case deposition rates are not accounted for since, in any case, $W \propto Pop$. The model includes the possibility to create a stochastic demographic process (see below), but the user can also set fix values for population or set the parameters in a way that the stochastic process is constrained. In any case, the user does have to provide a value for the carrying capacity ($K$) as this will limit population growth. *Defined in code as* `Pop`.
* **Anthropogenic deposition** ($A$): Amount of bone kilogram/year deposited by each group at a time $t$. This is a continuous variable, with range $[0,\infty]$, measured in *Kg*. See *Anthropogenic deposition protocol* for full definition.
* **Natural deposition rates** ($r$): This is a continuous variable, with range $[0,0.5]$, measured in *cm/year*. Because, under normal circumstances, bones are thicker that any possible amount of earth deposited per year, even in a perfectly uncorrupted archaeological sequence (which is what is being modelled here), those would occupy microstrats belonging to different years. This variable is one of the responsibles for how many microstrats will each bone be occupying. See *Depth protocol* to understand how it works. *Defined in code as* `r`. 
* **Site function**: Has not been considered as a variable *per se* but, rather, as a group of variables, which are defined by the functionality of the site, and that condition the outcome of $A$. See *Anthropogenic deposition protocol* to see how these are modelled. 
* **Site type**: Site type (whether a site is a cave, a rockshelter or an open-air camp) can heavily condition the deposition rates at any archaeological location. However, in order to reduce uncertainty and not make an overcomplex model, we have decided to embed this condition, and the possible expert knowledge related to it, within the definition of the variable $r$.

## Implementation

This simulation for the creation of the archaeological record has been divided in three phases, or protocols. First, we populate the site, according to a stochastic demographic process, second we generate a sample for each $t$ and, in the third and final step, we distribute the amount of waste for each $d$.

In order to fully understand the process, first we will show the protocols and functions used.

### Population ($Pop$) Pop-protocol

This protocol generates a stochastic demographic process with maximum population $\sim K$. It is based on three functions. The first function `Gpd()` is the core of the protocol. It receives a `data.frame` with a specific number of individuals (`nrow`), their age (`df[,1]`) and their sex (`df[,2]`) and produces another data frame with the same format but with a different population based on the current one. Introduced in a loop, this function produces a time series of population, which ensures the Markov property of the stochastic process $p(x_n+1|x_n)$.

However, this function also relies on two other functions: `death()` and `K_lim()`.
`death()` is the process of people dying each year. It is based on an age-structured probability matrix, where infants and old people have more probabilities of deceasing. The matrix is provided, but the user can set its own. `K_lim()` limits the population when it reaches $K$. The user should specify the appropriate value for $K$ according to the size of the site, its type, the group economy, etc. Also, the user can change the probability that exceeding people dies with parameter `prob`. Default is 0.8.

```{r}

### Population protocol

## Function 1. Generation of population dynamics
#' @title Gpd
#' Returns a data.frame with two columns, where the number of rows is the number of
#' people. The first column contains the ages and the second column contains the sex.
#' @param x: Input data. A data frame or matrix with two columns and nrow = Initial
#' population. One row per individual. The first column is the age of the individual.
#' The second column is the sex of the individual, and must be c("F","M").
#' @param W_fer_age: Vector with two values. The first value is the youngest age
#' at which is considered that women can have children for prehistoric societies.
#'  The second value is the oldest age at which is considered that women can 
#'  have children. Default is c(10,30).
#' @param M_fer_age: Vector with two values. The first value is the youngest age
#' at which is considered that men can have children for prehistoric societies.
#' The second value is the oldest age at which is considered that men can have 
#' children. Default is c(15,40)
#' @param  P_o: Probability of a woman having a son per year. Default is 0.3.
#' @param prob: Probability that an individual will die if total population
#' exceeds K. Default is 0.8
#' @param K: Carrying capacity.
#' @param ...: This function uses the embedded function death(). 
#' Their arguments can be added.
#' @export

Gpd <- function(x, W_fer_age = c(10,45), M_fer_age = c(15,55),
                P_o = 0.3, prob = 0.8, K, ...){
  
  ### Process of having offspring
  
  # Female fertile population
  W <- x[x[,2]=="F",]
  W_fert <- W[W$Age>W_fer_age[1] & W$Age<W_fer_age[2],]
  
  # Male fertile population
  M <- x[x[,2]=="M",]
  M_fert <- M[M$Age>M_fer_age[1] & M$Age<M_fer_age[2],]
  
  ## Probability of having descendance per woman
  # Penalisation in case there are too few men
  pen <- round(nrow(M_fert)*2/nrow(W_fert),2) ## Assumes one man can have two women
  pen[pen>1] <- 1 ## The men penalisation can never multiply the birth rate per woman
  
  ## Probability of a woman having a son per year
  P_o <- P_o*pen
  
  Offspring <- sum(rbinom(nrow(W_fert),1,P_o))
  x$Age <- x$Age+1 ## They get one year older
  New_pop <- data.frame("Age" = rep(0,Offspring),                        
                        "Sex" = sample(c("M","F"),Offspring,prob=c(0.5,0.5),replace = TRUE))
  x <- rbind(x,New_pop)
  
  ### Process of dying
  
  vec_d <- apply(x,1,death,...)
  x <- x[vec_d==0,]
  
  ## Apply carrying capacty restrictions
  x <- K_lim(x, K = K, prob = prob)
  
  return(x)
}

## Function 2. Simulation of death process
#' @title death
#' Returns a value (0,1) where 0 = person lives and 1 = person dies, based
#' on pd (the probability matrix)
#' Thought to use with apply
#' @param x: An integer with the age of the person
#' @param pd: The probability matrix for mortality by age
#' @export

## The age-structured data frame is based on Gurven, Kaplan and Supa, 2007.
## It is extracted adapted after computation from their text (not graphs or tables)

death <- function(x,pd=data.frame("Age" = c(0:99),
                                  "P_d" = c(rep(0.14,1),
                                            rep(0.16,4),
                                            rep(0.05,5),
                                            rep(0.01,24),
                                            rep(0.03,14),
                                            rep(0.1,10),
                                            rep(0.3,42)))){
  age <- as.numeric(x[1])
  return(rbinom(1,1,prob = pd[pd$Age==age,2]))
}

## Function 3. Simulation of carrying capacity limitation
#' @title K_lim
#' If the population exceeds the carrying capacity, it eliminates oversize
#' with 0.8 probability per person exceeding.
#' @param x: Data frame or matrix. Population (number of people)
#' @param K: Integer. Carrying capacity. Provided by the user
#' @param prob: It is the probability of dying when surpassing carrying capacity
#' @export

K_lim <- function(x,K,prob = 0.8){
  p <- nrow(x)
  if (p>K){
    o <- rbinom(p-K,1,prob)
    o <- sum(o[o==1])
    o[o==0] <- 1 ## Avoids problem eliminating all the df if remove == 0
    x <- x[-sample(1:nrow(x),o,replace = FALSE),]
  }
  return(x)
}


```

### Anthropogenic deposition ($A$) A-protocol

This generates the amount of human waste produced for each $t$ (In bone kilograms). It is defined as:

$$A(t)= Pop(t)\times O(t)\times F(t) \times G(t), t = 1,2,...,T_{death} \tag{1}$$
Where:

* $Pop(t)$ is a discrete variable representing the number of living people at a time $t$.
* $O(t)$ is the proportion of time of the year that the group spends in the camp for each time $t$. It is a continuous variable with range $[0,1]$. In the code, this is defined as the parameter `in_camp_stay` and it is provided as the number of weeks, considering 52 the maximum number of weeks for a year.
* $F(t)$ is the proportion of bone for the full weight of each Kg of an animal consumed for a time $t$. This is a unit interval variable $[0,1]$.
* $G(t)$ is the quantity, in Kg, of a (full-weight) animal consumed in a site by each individual at a time $t$. This is a continuous variable with range $[0,\propto K]$. This is a hierarchical variable, defined as follows:

$$G(t)=\frac{C(t)\times S(t)}{R(t)} \tag{2}$$

Where:

$S(t)$ is the proportion of meat consumed within the camp. $[0,1]$

$R(t)$ is the quantity of kilocalories produced for each kilogram of meat. This is a continuous with range $[1,2.5]$. Total kilocalories have been divided by 1000 for easier computation.

And $C(t)$ is the quantity of kilocalories, extracted from meat, consumed by person for each time $t$, and it is defined as

$$C(t)=B(t) \times M(t) \tag{3}$$
Where 

$B(t)$ is the quantity of kilocalories consumed by an individual for each $t$, and it has a range $[1.5,2.5] \times 365$. For easier computation, the actual average of kilocalories consumed per person/day has been divided by 1000.

$M(t)$ is the proportion of kilocalories coming from meat relating to the total calories consumed per each individual. $[0,1]$.

As it can be seen, the above definitions embed the functionality of the site, which can be considered by the user. In practice, setting the variables $O(t) = 1$ and $S(t)=1$ would eliminate site functionality, but would assume that a site is inhabited by all the group during the full year, and that this group consumes all the food within the site.

Up to now, we have obtained the value for the variable $A$, which is the amount of kilograms of bone for each time $t$. From this, extracting the number of samples for each $t$ is straightforward

$$W(t)=\mbox{Integer part of } \Bigg(\frac{1000 \times A(t)}{4} \Bigg) \tag{4}$$

Considering 4 grams of non-heated bones necessary for a sample.

This protocol is captured through the following code.

```{r}
## Function 4. 
#' @title A_rates
#' Simulation of samples generated per year (anthropogenic deposition rates)
#' Returns the Kilograms of bone produced per year in a site.
#' @param x: Integer (user provided), vector or data.frame. It is the number of 
#' people inhabiting the site. If data.frame, the number of people is the number 
#' of rows. If vector, it is the length of the vector.
#' @param kcalpers: Quantity of kilocalories consumed per year per adult person.
#' For easier computation, it has a range of [1.5,2.5]. Defaul is 2
#' @param kcalmeat_eat: Proportion of kilocalories extracted from meat. Range [0,1].
#' Default is 0.45, based on Cordain et al (2000)
#' @param kcalmeat_prod: Quantity of kiocalories per meat kilogram. Range [1,2.5]
#' Default is 1.5, considering goat meat.
#' @param in_camp_eat: Proportion of food consumed within the camp. Range [0,1]. 
#' Default is 0.55 based on Collette-Barbesque et al. (2016).
#' @param in_camp_stay: Proportion of time spent in a specific camp. Valid for 
#' groups with high mobility. The proportion is computed within the function, but
#' the user introduces the weeks of occupation of the camp, where the maximum is
#' 52 (full year). Default is 13 (weeks, or 0.25 of the year).
#' three months a year.
#' @param kg: Bone proportion for each animal consumed. Default is 0.07 for now, 
#' based on Johnston et al. (2021), but perhaps I should change that. Review
#' @export

A_rates <- function(x,
                   kcalpers = 2,
                   kcalmeat_eat = 0.45,
                   kcalmeat_prod = 1.5,
                   in_camp_eat = 0.55,
                   in_camp_stay = 13,
                   kg = 0.07){
  
  if (in_camp_stay > 52) stop('A year cannot have more than 52 weeks')
  
  if (is.data.frame(x) == TRUE){
    P <- nrow(x)
  } else if (length(x) == 1){
    P <- x
  } else {
    P <- length(x)
  }
  
  B <- kcalpers*365
  M <- kcalmeat_eat
  R <- kcalmeat_prod
  S <- in_camp_eat
  O <- round(in_camp_stay/52,2)
  Kg <- kg

  C <- B*M
  
  G <- (C*S)/R ## Quantity (in kg) of animal consumed per person in camp during year t
  
  A <- P*O*Kg*G ## kilograms of meat consumed within a camp by the group
  W <- round((1000*A)/4) ## samples extracted from that meat
  
  return(W)
}
```

### Depth protocol D-protocol
This protocol is designed to respond for the fact that, despite a bone is deposited in a time $t$, it can occupy the stratigraphic space of many subsquent years until us fully buried. The years it takes to be fully buried depends on the thickness of the bone and the natural deposition rates $r$.

Since the thickest bones are usually the minority within a sampl, whereas the majority is usually conformed by smaller bones, we have considered that bone presence diminishes exponentially as it departs from $t_0$, being $t_0$ the year when it was deposited. Thus, this process can be modelled as follows:

$$W_b(t_u,t_l)=W(t=t_l)\times(1-e^{-\lambda(t_u-t_l)}), t_u < t_l \tag{5}$$

Where

* $W$ has been defined before, and it is the number of samples deposited at a time $t_l$
* $W_b$ is the number of samples buried at a time $t_u$ from the ones generated at $t_l$. Thus, $t_u \geq t_l$
* $t_l$ is the moment in time $t$ when the samples $W$ are deposited.
* $t_u$ is each time $t$, $\geq t_l$, when the sample is being buried according to the parameter $r$. Thus, at $t_{u_{max}}$, the sample is completely buried.

$t_{u_{max}}$ depends on two factors:

* $L$ is the maximum thickness of the sample (the thickest considered bone), in cm.
* $r$ is the deposition rates, in cm. For this model, we have considered the values 0.1, 0.2, 0.3, 0.4 and 0.5

Thus

$$t_{u_{max}}=\frac{L}{r} \tag{6}$$

Is the time for the sample to be fully buried.

**Estimation of $\lambda$**

For the exponential process to work correctly, we need to estimate $\lambda$ in equation $(5)$. In order to do so, we consider the following

$$\frac{W_b(t_{u_{max}}=1,t_l)}{W(t_l)} \tag{7}$$

Is the proportion of buried samples in $t_{u_{max}}$ from the ones that were deposited in $t_l$. Thus,

$$\frac{W_b(t_{u_{max}}=1,t_l)}{W(t_l=1)}=1-e^{-t_{u_{max}}\lambda} \tag{8}$$

However, if we consider all of the samples buried in $t_{u_{max}}$, then $t_{u_{max}} =1$, but in this situation $\lambda \rightarrow \infty$ and, thus, the solution to this equation is too complex. Therefore, we can give an error margin to the buried samples in $t_{u_{max}}$ (say $99\%$). In this case, $\lambda$ can be easily computed as follows

$$1-e^{-\lambda t_{u_{max}}}=\theta_e$$

and thus

$$\lambda=\frac{-log(1-\theta_e)}{t_{u_{max}}} \tag{9}$$

Where $\theta_b$ is the proportion of buried samples in $t_{u_{max}}$

The following function captures this process

```{r}

## Function 5. 
#' @title D_along
#' It distributes the samples produced in one specific year along the depth of the
#' site, without any kind of post-depositional alteration, and according to 
#' pre-established post-deposition rates. Returns a vector with the samples exponentially
#' distributed. The vector is as long as L/r and the error (Pb) is considered.
#' @param x: Integer (user provided), vector or data.frame. It is the number samples
#' produced at a specifi 't'.
#' @param r: Is the deposition rates. At this moment, values > than 0.5 are not accepted.
#' If values with two or more decimals are provided, the function will automatically round 
#' the value to one decimal.
#' @param Max_bone_thickness: Maximum thickness of bones within the assemblage. Four
#' values are possible: small ('s') = 2.5 cm; medium ('m') = 5 cm; large ('l') = 10 cm
#' and very large ('vl') = 20 cm. Default is 'm'.
#' @param Pb: Proportion of samples buried sample at tmax, considering error. Pb 
#' cannot be higher or equal to 1. Default is 0.9999, which stands for 99.99%.
#' @export

D_along <- function(x,r, Max_bone_thickness = "m", Pb = .9999){
  
  # Define W
  W <- x
  
  # Define parameter r
  r <- round(r,1)
  if(r>0.5) stop("values > 0.5 are not accepted for param 'r'")
  
  # Define parameter Max_bone_thickness (L)
  if (Max_bone_thickness == 's'){
    L <- 2.5
  } else if (Max_bone_thickness == 'm'){
    L <- 5
  } else if (Max_bone_thickness == 'l'){
    L <- 10
  } else if (Max_bone_thickness == 'vl'){
    L <- 20
  }
  
  # Constraints for parameter Pb
  if (Pb >= 1) stop("Pb must be lower than 1")
  
  # Define tmax
  tm <- L/r
  ss <- rep(0,round(tm)) ## Vector to distribute samples over
  
  # Estimate lambda
  l <- -log(1-Pb)/tm
  tl <- 0 # Year where the sample is deposited
  tu <- 1 # Year when it is covered
  
  for (i in 1:tm){
    Wb <- W*(1-exp(-l*(tu-tl))) ## Apply formula
    Wbprev <- W*(1-exp(-l*((tu-1)-tl))) ## To substract values previous to tu
    ss[i] <- round(Wb-Wbprev) ## Number of samples for each year
    tu <- tu + 1
  }
  
  return(ss)
}

```


### Example and simulation

With the above functions, the user can model (1) a generative demographic process, (2) how many different dates would a group of people produce in a site, according to different constraints and (3) how those dates distribute along the depth of a site under the assumption that there has not been any kind of record loss or post-depositional process (this will be modelled in a second layer of modelling).

However, in order to account for the chronological occupation of  the site, a demographic process must be produced, where the sample is generated accordingly. The following functions can produce this. In the function `Rec_c` the user can consider whether to divide the total sample by the area of the site, or not. In addition, the user can used the modelled values (with the functions above) as an input to this function, or introduce them directly, for example, in the case that fix population rates per year were preferred. 

```{r}
## Function 6. 
#' @title Pop_stoch
#' It reproduces the population stochastic process. The result is a vector with the 
#' number of individuals for each year.
#' @param Pop: Integer with the initial population
#' @param K: Only if model_pop = TRUE. In this case, it is the carrying capacity
#' @param ts: Time-span, the number of years considered for the process
#' @param prob: Probability that an individual will die if total population
#' exceeds K. Default is 0.8
#' @param K: Carrying capacity.
#' @param ...: This function uses the functions Gpd(), and thus it also uses
#' death() and K_lim(). The additional arguments can be added.
#' @export

Pop_stoch <- function(Pop, K, prob = 0.8, ts, ...){
  
  ## Create initial population
  Ip <- Pop
  Ip <- data.frame("Age" = sample(10:30,Ip,10:30, replace = TRUE),
                   "Sex" = sample(c("M","F"), Ip, prob = c(0.5,0.5), replace = TRUE))
    
  pop <- c()
  
  ## Run stochastic process  
  for (i in 1:ts){
    pop[i] <- nrow(Gpd(Ip, K = K, prob = prob, ...))
    Ip <- Gpd(Ip, K = K, prob = prob, ...)
  }
  
  return(pop)
}

## Function 7. 
#' @title Rec_c
#' It spreads the different amount of samples accord different profundities
#' @param x: Vector with the number of samples per year
#' @param persqm: If TRUE, the total record is divided by the area of the site
#' (in square meters), so that the output belongs to each square meter. Default is
#' FALSE
#' @param area: Only if persqm = TRUE. In this case, the total area of the site 
#' must be provided
#' @param ts: Time-span, the number of years considered for the process
#' @param InitBP: Initial year considered for the process. In BP.
#' @param ...: This function uses the functions D_along(). The additional 
#' arguments can be added.
#' @export

Rec_c <- function(x, persqm = FALSE, area, ts, InitBP, ...){
  
  ## Whether sqm division must be included or not
  if (persqm == TRUE){
    x <- x/area
  }
  
  ## Spread dates along different depths
  matdim <- length(x)
  mat <- matrix(nrow=matdim,ncol=matdim)
  
  for (i in 1:matdim){
    new <- D_along(x[i], ...)
    st <- i-1
    pos <- c(rep(0,st),new)
    pos <- pos[1:matdim]
    mat[,i] <- pos
  }
  mat[is.na(mat)] <- 0
  
  ## Names for columns (each year)
  years <- seq(InitBP,InitBP-ts)
  nyears <- c()
  for (i in 1:matdim){
    nyears[i] <- paste0(years[i], " BP")
  }
  colnames(mat) <- nyears
  
  ## Names for rows (each depth)
  ## Extract arguments as a list
  Extract_param <- function(x, ...){ 
    extras <- list(...)
    return(list(extras=extras)) 
  }

  dr <- Extract_param(D_along, ...)
  dr <- dr$extras$r
  
  d <- rev(cumsum(rep(dr,nrow(mat)))) ## computes depths
  rownames(mat) <- paste0("d = ", d, " cm")

  return(mat)
}

```


After this, we can start the simulation, in this case with the parameters seen below.

```{r}
set.seed(1234)
Ps <- Pop_stoch(Pop=100, ts= 100, K = 150)
samp <- unlist(lapply(Ps,A_rates)) ## Extract sample per time steps
Rec <- Rec_c(samp, InitBP = 7500, ts = 100, r = 0.2, Max_bone_thickness = "m")
```

With which we can obtain, among other things, the distribution of the samples for each specific date along the depth of the sit, and its comparison to the total population. For better comprehension, we have decided not to include all of the dates in the plot below, but only some of them as an example. The user can also check how the model work and its results [here](https://acortell3.shinyapps.io/archaeo_record_model). 

*The total number of population has been adapted for visualisation*

```{r, echo = FALSE, message=FALSE}

## Some nice plots
library(viridis)
## Plot dates
#sdate <- 1
#edate <- 5
#sdepth <- 1
#edepth <- 5
#barplot(Rec[sdepth:edepth,sdate:edate], col = viridis(10), legend = rownames(Rec)[sdate:edate],
#        xlab = "Years BP", ylab = "nsamples", main = "Distribution of samples for each year at different depths")

tRec <- t(Rec)
barplot(tRec[c(1:4,77:79),], col = viridis(10), legend = colnames(Rec)[c(1:4,77:79)],
        xlab = "Depth", ylab = "nsamples", main = "Distribution of specific years along depth with population")
lines(Ps*300, col = "darkred", lwd = 1.5)
```

